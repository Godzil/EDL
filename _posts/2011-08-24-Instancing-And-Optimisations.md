---
layout: post
author: Savoury SnaX
title: Instancing and Optimisations
---

 Over the last few days I have been looking into the code generated by the compiler in order to reduce its size further. One area that needed some work is due to the way globals are being used (for instance in holding the current state). LLVM refuses to remove useless loads and stores from these variables, probably because a global is treated as a volatile (although i`m not entirely sure). No amount of fiddling with flags and options would help, so in the end I resorted to writing a custom optimisation pass.

 In the case of state variables, I know by design (a single edl file is a black box), that they only change at one point within the code. Which means that if a code block tests to see if its in a state, does some work, then tests if its in a different state, the second test is redundant if we went through the first block. The optimisation pass is trivialy simple, for any given function - it simply removes duplicate loads to the state variable. The normal LLVM optimisation passes can then kick in and do the heavy lifting. It works pretty well, although i had to run the optimisation passes twice due to the inlining passes providing further optimisation possibilities to my own.

 I`m still not completely happy with the state code, I think there are further improvements to be had, and there are definately significant improvements to be made in other areas.

 The other feature I added was INSTANCEs. They allow an edl file, to utilise other edl files (a little like an import directive in java). At present the compiler will only allow access to the PINs of the INSTANCEd module, in the future functions and globals that are not marked as INTERNAL will also be made visible. 
 
 Scoping rules are a little different to normal for INSTANCEs. Essentially non INTERNAL globals/functions/pins are only accessable from the file that includes the INSTANCE. Hopefully the documentation makes a bit more sense of the issue.
