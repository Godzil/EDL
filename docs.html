---
layout: default
title: Emulation Description Language - Docs
---

 <div class="title">
    <a class="extra1" href="/EDL/">News</a> 
    <a class="extra1" href="/EDL/about.html">About</a> 
    <a class="extra2" >Docs</a>
    <a class="extra" href="http://github.com/SavourySnaX/EDL/tree/master">Src</a>
    <a class="project">Emulation Description Language</a>
  </div>

<div class="post">

<h2><u>Comments</u></h2>

<p>Comments in EDL begin with <b>#</b> and end at the end of the current line</p>

<pre style="background-color:#CCCCCC">
<b>#</b> This is a comment
</pre>
<p></p>
<h2><u>Integers</u></h2>

<p>At present EDL supports binary (% prefix),decimal and hexadecimal ($ prefix) representations for any numeric constants</p>

<pre style="background-color:#CCCCCC">
%1010
$A
10
</pre>

<p> The above are all equivalent. 

<h2><u>Variables</u></h2>

<p>To declare a variable called foo, which is 8 bits in width (C equivalent unsigned char) in EDL :</p>

<pre style="background-color:#CCCCCC">
<b>DECLARE</b> foo[8];
</pre>

<p>Variables can either be declared globally or within a block, however at present the compiler requires the declaration of the variable before its use. Scoping rules are the same as C.</p>

<p>Note variables are <em>ALWAYS</em> initialised to zero, and it is not possible to give them any other initial value (with the exception of constants).</p>

<h2><u>Constant Variables</u></h2>

<p>Constant variables are supported, although at present the compiler will not treat them as such from an optimisation standpoint. See Aliases below.</p>

<h2><u>Aliases</u></h2>

<p>One of the more powerful (esoteric?) features of variable declarations is the ability to declare an ALIAS. Imagine a processor status register, these are often a sequence of named bit flags, packed into a larger register.</p>

<pre style="background-color:#CCCCCC">
<b>DECLARE</b> Flags[3] <b>ALIAS</b> sign[1]<b>:</b>zero[1]<b>:</b>carry[1];
</pre>

<p>The above would declare a Flags variable of 3 bits in length. It would also declare sign as the MSB (Most significant bit), zero as the middle bit, and carry as the least significant bit. <b>:</b> is a bit concatenation operator, at present it is not supported on generic expressions, but that will change.</p>

<p>To declare a constant variable, you can do :</p>

<pre style="background-color:#CCCCCC">
<b>DECLARE</b> MyMagicConstant[8] <b>ALIAS</b> %01010101;
</pre>

<p>The above would create MyMagicConstant (8 bits in length) with a decimal value of 85. It will be impossible to change the value of this variable.</p>

<p>A more complicated version of the above 2 ideas can be find in the 8080 emulation. The 8080 processor has a status register with 3 unused bits, according to the documentation, these bits are constant.<p>

<pre style="background-color:#CCCCCC">
<b>DECLARE</b> FLAGS[8] <b>ALIAS</b> s[1]<b>:</b>z[1]<b>:</b><em>%0</em><b>:</b>ac[1]<b>:</b><em>%0</em><b>:</b>p[1]<b>:</b><em>%1</em><b>:</b>cy[1];
</pre>

<p>Which gives bits 5 and 3 a value of 0, and bit 1 a value of 1. Even if you were to assign a value to FLAGS within code, it would be impossible to modify the constant bits!</p>

<h2><u>Assigning Values</u></h2>

<p>Unlike many modern languages, = is not used to assign values to variables. Assignment like other features of the language was born from a need to keep the emulation description as close to the manufacturers description of the hardware. Assignment in EDL is therefor a directional affair and uses the symbols <b>&lt-</b> and <b>-&gt</b> and allows assignment in either direction.</p>

<pre style="background-color:#CCCCCC">
foo <b>&lt-</b> $AA;
$AA <b>-&gt</b> foo;
</pre>

<p>The above expressions are the same, and both assign foo with the value $AA.</p>

<h2><u>Assigning Values - Automatic promotion/truncation</u></h2>

<p>It is important to remember (since at present no warnings are generated by the compiler), that when assigning a value to a variable, the value will be truncated or expanded (as an unsigned integer) to the bit size of the variable. E.g. </p>

<pre style="background-color:#CCCCCC">
<b>DECLARE</b> foo[2];

foo<b>&lt-</b>%1;	# foo will be given the value %01 (%1 expanded to 2 bits)
foo<b>&lt-</b>$A;	# foo will be given the value %10 (%1010 clamped to 2 bits)
</pre>
<p></p>

<h2><u>Input / Output</u></h2>

<p>At present EDL does not support IO operations! To provide input into the system, external code (C program) must be provided. This is obviously a hinderance,  and will change in the future. Output is possible via the <b>DEBUG_TRACE</b> expression, but its only really there for debugging - hence its name.<p>

<h2><u>Debug Trace</u></h2>

<pre style="background-color:#CCCCCC">
<b>DEBUG_TRACE</b> "A string";
</pre>
<p>Will output a single line to the console, saying :</p>

<pre style="color:white; background-color:#000000">
A string
</pre>
<p></p>

<pre style="background-color:#CCCCCC">
<b>DEBUG_TRACE</b> foo;
</pre>

<p>Will output the contents of the variable foo plus its identifier to the console :</p>

<pre style="color:white; background-color:#000000">
foo(10101010)
</pre>

By default variables are displayed in binary notation, this can be modified by using the <b>BASE</b> directive.</p>

<pre style="background-color:#CCCCCC">
<b>DEBUG_TRACE</b> <b>BASE</b> 16,foo;
</pre>

<p>Would output :</p>

<pre style="color:white; background-color:#000000">
foo(AA)
</pre>
<p></p>

<pre style="background-color:#CCCCCC">
<b>DEBUG_TRACE</b> "10 in base 2 : ",10," and in base 16 : ",<b>BASE</b> 16,10;
</pre>

<p>Should obviously be :</p>

<pre style="color:white; background-color:#000000">
10 in base 2 : 101 and in base 16 : A
</pre>
<p></p>

<h2><u>Handlers</u></h2>

<p>Handlers are supposed to be functions that are run when a pin changes value. At present however they are simply functions. This will be updated in a future version when the feature is implemented. In C a special function main defines the start of execution for a program. EDL has no such facility at present, again a c program should be used as the driver.</p>

<pre style="background-color:#CCCCCC">
<b>HANDLER</b> hello
{
	<b>DEBUG_TRACE</b> "Hello World!";
}
</pre>

<p>and the c driver : </p>

<pre style="background-color:#CCCCCC">
extern void hello();

int main(int argc,char** argv)
{
	hello();
}
</pre>

<p>would produce :</p>

<pre style="color:white; background-color:#000000">
Hello World!
</pre>
<p></p>

<h2><u>States</u></h2>

<p>Because the hardware under emulation can usually be thought of as a state machine (certainly a cpu can), EDL provides a simple state machine declaration.</p>

<pre style="background-color:#CCCCCC">
<b>STATES</b> a<b>,</b>b<b>|</b>c
{
	<b>STATE</b> a
	{
		<b>DEBUG_TRACE</b> "State a";
	}
	<b>STATE</b> b
	{
		<b>DEBUG_TRACE</b> "State b";
	}
	<b>STATE</b> c
	{
		<b>DEBUG_TRACE</b> "State c";
	}
}
</pre>

<p><b>,</b> means auto increment, where as <b>|</b> acts as an auto increment barrier. Each time the <b>STATES</b> block is reached, it will perform the defined action for its current state, if the state is auto incrementing, the state will be moved onto the next state. States are moved/changed on entry. The above code if entered 4 times, would produce :</p>

<pre style="color:white; background-color:#000000">
State a
State b
State a
State b
</pre>

<p>It is also possible to define sub states, at present it is best to only make the sub states auto increment because of the rule that states move on entry. The following code and result show the headache that can happen, here the code was run 8 times :</p>

<pre style="background-color:#CCCCCC">
<b>STATES</b> a<b>,</b>b
{
	<b>STATE</b> a
	{
		<b>STATES</b> a1<b>,</b>a2
		{
			<b>STATE</b> a1
			{
				<b>DEBUG_TRACE</b> "State a1";
			}
			<b>STATE</b> a2
			{
				<b>DEBUG_TRACE</b> "State a2";
			}
		}
	}
	<b>STATE</b> b
	{
		<b>STATES</b> b1<b>,</b>b2
		{
			<b>STATE</b> b1
			{
				<b>DEBUG_TRACE</b> "State b1";
			}
			<b>STATE</b> b2
			{
				<b>DEBUG_TRACE</b> "State b2";
			}
		}
	}
}
</pre>
<pre style="color:white; background-color:#000000">
State a1
State b1
State a2
State b2
State a1
State b1
State a2
State b2
</pre>

<p>Unlike normal variables, state blocks are always global, but tied to a handler. This is so that the state machine can be adjusted from an external function.</p>

<h2><u>Adjusting States</u></h2>

<p>To force execution of a different state next time the state block is reached, you can use 1 of 2 methods.</p>

<pre style="background-color:#CCCCCC">
<b>HANDLER</b> example
{
	<b>STATES</b> first<b>|</b>second
	{
	}
}
</pre>

<pre style="background-color:#CCCCCC">
<b>NEXT</b> example.second;
</pre>
<p>The above demonstrates that it is not necassary to implement a state, the default implementation will do nothing - but the auto increment rules will still apply. The <b>NEXT</b> instruction shown would set the examples state machine to second the next time it runs.</p>

<pre style="background-color:#CCCCCC">
<b>HANDLER</b> example
{
	<b>STATES</b> first<b>|</b>second<b>|</b>third
	{
		<b>STATE</b> first
		{
			<b>PUSH</b> example.third;
			<b>PUSH</b> example.second;
		}
		<b>STATE</b> second
		{
			<b>POP</b> example;
		}
		<b>STATE</b> third
		{
			<b>POP</b> example;
		}
	}
}
</pre>

<p>The above shows the other method of changing states, here if the states block was entered 4 times, it would go first,second,third and finally back to first. <b>PUSH</b> and <b>POP</b> can be used to remember a state and return to it at some future point. <b>POP</b> is currently a very expensive operation in EDL the compiler spits out a fair amount of code in order to allow the correct return location for sub states. This will improve in a future version.</p>

<h2><u>Conditions</u></h2>

<p>Conditions much like in c are done using the <b>IF</b> statement. At present there is no concept of an otherwise/else clause. </p>

<pre style="background-color:#CCCCCC">
<b>IF</b> $A == 10
{
	<b>DEBUG_TRACE</b> "It certainly does!";
}
</pre>

<p>EDL supports <b>==</b>,<b>!=</b>,<b>&lt=</b>,<b>&lt</b>,<b>&gt=</b>,<b>&gt</b> operators, which are ; is equal to, is not equal to, is less than or equal, is less than, is greater than or equal to, is greater than.<p>
<p>The above operators can be combined via any of the boolean operators <b>&</b>,<b>|</b> and <b>^</b>, which are ; and, or, xor. <b>IF</b> always expects a single bit expression, and will execute the block of code below it if that expr is 1. The <b>==</b> etc, operators always return a single bit. This is why there is no C equivalent of <b>&&</b> and <b>||</b>.

<h2><u>Testing State</u></h2>

<p>One useful feature is the ability to check which state a state machine is currently in. The <b>@</b> operator is used for this, it will produce a 1 or 0 value depending on if the state machine is in the mentioned state or not. e.g.</p>

<pre style="background-color:#CCCCCC">
<b>IF</b> example.first<b>@</b>
{
	<b>DEBUG_TRACE</b> "Current state for example is state first";
}
</pre>

<h2><u>Arithmetic</u></h2>

<p>EDL currently only supports add and subtract operations (I forgot to provide support for multiply,divide,remainder). They work as expected, but its worth remembering that for expressions the left and right side of the expression will always be expanded to the same bit size.</p>

<pre style="background-color:#CCCCCC">
<b>DECLARE</b> foo[8];

foo <b>&lt-</b> %01 + %1011;	# %01 is a smaller bit size than %1011
			#therefor %01 is expanded to %0001 before the
			#addition.

<b>DEBUG_TRACE</b> foo;
</pre>

<pre style="color:white; background-color:#000000">
foo(00001100)
</pre>
<p></p>

<h2><u>Casting</u></h2>

<p>In EDL casting is a way to force the value of an expression to be a particular bit size. A future update will hopefully allow the cast to be applied on assignment to, although at present this is not supported.</p>

<pre style="background-color:#CCCCCC">
<b>DECLARE</b> foo[8] <b>ALIAS</b> %00111100;
<b>DECLARE</b> bar[8];

bar <b>&lt-</b> foo[2];		# will assign %00000000 to bar
bar <b>&lt-</b> foo[2..6];	# will assign %00001111 to bar
</pre>

<p>As can be seen above, casting also allows you to take a bit range from an expression. Essentially foo[2] is shorthand for foo[0..1].</p>

<h2><u>Affectors</u></h2>

<p>EDL to date has been concerned with the emulation of processors. One feature common to almost all processors is the status word. As has already been shown, <b>ALIAS</b> allows the status word to be declared exactly as the processor works. But how about the updating of the various status' within that word? Well this is the role of affectors, they allow common cpu flags to be captured from any expression. </p>

<pre style="background-color:#CCCCCC">

<b>DECLARE</b> register1[8];
<b>DECLARE</b> register2[8];
<b>DECLARE</b> register3[8];

<b>DECLARE</b> FLAGS[8] <b>ALIAS</b> s[1]<b>:</b>z[1]<b>:</b><em>%0</em><b>:</b>ac[1]<b>:</b><em>%0</em><b>:</b>p[1]<b>:</b><em>%1</em><b>:</b>cy[1];

<b>AFFECT</b> s <b>AS BIT</b>(7)
{
	register1 + register2
} <b>-&gt</b> register3;
</pre>

<p> the above would add register1 and register2 together and store the result in register3. It would also store bit7 of the result into the s register of FLAGS. Affectors can be combined, so : </p>

<pre style="background-color:#CCCCCC">

<b>DECLARE</b> register1[8];
<b>DECLARE</b> register2[8];
<b>DECLARE</b> register3[8];

<b>DECLARE</b> FLAGS[8] <b>ALIAS</b> s[1]<b>:</b>z[1]<b>:</b><em>%0</em><b>:</b>ac[1]<b>:</b><em>%0</em><b>:</b>p[1]<b>:</b><em>%1</em><b>:</b>cy[1];

<b>AFFECT</b> s <b>AS BIT</b>(7),z <b>AS ZERO</b>
{
	register1 + register2
} <b>-&gt</b> register3;
</pre>

<p> would do as before, but also set the z bit of flags if the answer was zero (it would be cleared otherwise).</p>

<p>At present there are 6 different affectors available :</b>
<table border="1" cellpadding="2" cellspacing="1" width="100%">
<tr>
<td><b>BIT</b>(<i>number</i>)</td>
<td>Captures the bit specified from the expression result</td>
</tr>
<tr>
<td><b>SIGN</b></td>
<td>Captures the MSB (most significant bit) from the expression result</td>
</tr>
<tr>
<td><b>ZERO</b></td>
<td>If the expression result is zero, a 1 is stored, otherwise 0 is stored</td>
</tr>
<tr>
<td><b>PARITYEVEN</b></td>
<td>If the parity of bits in the expression is even a 1 is stored, otherwise 0 is stored. Parity is the count of bits equal to 1</td>
</tr>
<tr>
<td><b>PARITYODD</b></td>
<td>If the parity of bits in the expression is odd a 1 is stored, otherwise 0 is stored</td>
</tr>
<tr>
<td><b>CARRY</b>(<i>number</i>)</td>
<td>If a carry would have occurred from the given bit number, then a 1 is stored. Otherwise 0 is stored (see below)</td>
</tr>
</table>

<p><b>CARRY</b> at present is only supported for add and subtract operations. The bit number specified should be the point before where the carry would have occured to/from. This is a little awkward (and perhaps will change in the future).</p>

<pre style="background-color:#CCCCCC">
<b>DECLARE</b> register1[4] <b>ALIAS</b> %0001;
<b>DECLARE</b> register2[4] <b>ALIAS</b> %1111;
<b>DECLARE</b> register3[4] <b>ALIAS</b> %0000;
<b>DECLARE</b> register4[4];
<b>DECLARE</b> FLAGS[8] <b>ALIAS</b> s[1]<b>:</b>z[1]<b>:</b><em>%0</em><b>:</b>ac[1]<b>:</b><em>%0</em><b>:</b>p[1]<b>:</b><em>%1</em><b>:</b>cy[1];

<b>AFFECT</b> c <b>AS CARRY</b>(3)
{
	register1 + register2
} <b>-&gt</b> register4;

# register4 would be %0000
# c would be 1 - %0001 + %1111 is %0000 carry 1 ie Carry out of bit 3 is 1.

<b>AFFECT</b> c <b>AS CARRY</b>(3)
{
	register3 - register1
} <b>-&gt</b> register4;

# register4 would be %1111
# c would be 1 - %0000 - %0001 is %1111 carry 1 ie Carry into bit 3 is 1.

</pre>

<p>In the near future <b>OVERFLOW</b> will be added, along with the possibility to invert the meaning of the affector (especially useful for those processors that invert the carry flags meaning on subtraction e.g.6502).</p>

<h2><u>Shifts and Rotates</u></h2>

<p>Shifts and rotates and variations of them are catered for by the <b>ROL</b> and <b>ROR</b> operators. <b>ROL</b>(<i>value</i>,<i>bitsOut</i>,<i>bitsIn</i>,<i>amount</i>) will perform a transformation on value (shifting it left by <i>amount</i>) and oring in the <i>bitsIn</i>. <i>bitsOut</i> will be set to bits shifted out of <i>value</i>.</p>

<pre style="background-color:#CCCCCC">
<b>DECLARE</b> number[4] <b>ALIAS</b> %0110;
<b>DECLARE</b> shiftedOut[4];
<b>DECLARE</b> result[4];

result <b>&lt-</b> <b>ROL</b>(number,shiftedOut,%11,2);

<b>DEBUG_TRACE</b> result," ",shiftedOut;
</pre>

<pre style="color:white; background-color:#000000">
result(1011) shiftedOut(0001)
</pre>

<p><b>ROR</b> is the same as <b>ROL</b> excepts shifts right instead of left. At present a variable must always be passed to the <i>bitsOut</i> part of the expression, in the future this requirement will be relaxed to allow pure shifts to be implemented without having to have temporary storage.</p>

<p>A couple of examples of standard processor shifts and rotates :</p>
<table border="1" cellpadding="2" cellspacing="1" width="100%">
<tr>
<td><b>ROL</b>(number,shiftedOut,number[3..3],1)</td>
<td>Performs a rotate left of number by 1 bit</td>
</tr>
<tr>
<td><b>ROR</b>(number,shiftedOut,number[0..0],1)</td>
<td>Performs a rotate right of number by 1 bit</td>
</tr>
<tr>
<td><b>ROL</b>(number,shiftedOut,0,1)</td>
<td>Performs a logical shift left of number by 1 bit, (multiply by 2)</td>
</tr>
<tr>
<td><b>ROR</b>(number,shiftedOut,0,1)</td>
<td>Performs a logical shift right of number by 1 bit, (unsigned divide by 2)</td>
</tr>
<tr>
<td><b>ROR</b>(number,shiftedOut,1,1)</td>
<td>Performs an arithmetic shift right of number by 1 bit, (signed divide by 2)</td>
</tr>
</table>
<p></p>

<h2><u>Instructions</u></h2>

<p>Another fairly processor specific idea that is encapsulated in EDL, is that of instructions. This feature has been designed to allow disassemblers,assemblers,debug monitors and obviously emulation of cpu opcodes. An opcode on a processor is a sequence of bits that govern the operation that processor would perform. As an example the intel 8080 has an instruction which produces no results, commonly known as NOP (or No OPeration).</p>

<pre style="background-color:#CCCCCC">
<b>INSTRUCTION</b> "NOP" %00000000
{
}
</pre>

<p>"NOP" is the mnemonic representation of the instruction. %00000000 is the binary representation of the opcode.</p>

<h2><u>Executing Instructions</u></h2>

<p>Defining instructions is all well and good, but unless there is a way to execute them, they are only useful for generating disassembly.</p>

<pre style="background-color:#CCCCCC">
<b>EXECUTE</b> IR;
</pre>

<p>When execution of the program reaches this point, it will call out to the instruction whose opcode matches the current contents of the variable IR.</p>

<h2><u>Instructions continued</u></h2>

<p>At present due to limitations in the compiler, only 1 <b>EXECUTE</b> can occur in a given file, and it <em>MUST</em> occur before the definition of <b>INSTRUCTION</b>s. This will again be repaired in a future version of the compiler. </p>

<p>If <b>INSTRUCTION</b>s were limited to only a simple constant expression, declaring an emulation for a processor would be tedious at best. For this reason there are a few helpful features of <b>INSTRUCTION</b> definition. The next example shows one possible way to define the NOP instruction for the Intel 8080 which also takes care of the fact that the NOP instruction has multiple ocpodes (though only 1 is official).</p>

<pre style="background-color:#CCCCCC">
<b>INSTRUCTION</b> "NOP" %00:UNOFFICIAL[3]:%000
{
}
</pre>

<p>On the 8080, opcodes $00,$08,$10,$18,$20,$28,$30,$38 are all identical. The above <b>INSTRUCTION</b> definition basically defines all 8 of these as NOP. When the compiler sees an identifier with a bit size within an opcode definition it will automatically fill in the bits with all possible combinations.</p>

<h2><u>Mappings</u></h2>

<p>A second helpful feature is the idea of a <b>MAPPING</b>, they share a certain similarity to the C preprocessor macro #define. Although they are part of the language. The Intel 8080 has a number of opcodes which deal with the copying of one register into another (MOV A,B for instance). Mappings allow us to achieve all of the MOV register,register combinations in a single <b>INSTRUCTION</b> definition.</p>

<pre style="background-color:#CCCCCC">
<b>MAPPING</b> SSS[3]
{
	%000	"B"	B;
	%001	"C"	C;
	%010	"D"	D;
	%011	"E"	E;
	%100	"H"	H;
	%101	"L"	L;
#	%110			Not used
	%111	"A"	A;
}
<b>MAPPING</b> DDD[3]
{
	%000	"B"	B;
	%001	"C"	C;
	%010	"D"	D;
	%011	"E"	E;
	%100	"H"	H;
	%101	"L"	L;
#	%110			Not used
	%111	"A"	A;
}

<b>INSTRUCTION</b> "MOV %M1,%M0" %01:DDD:SSS
{
	DDD <b>&lt-</b> SSS;
}
</pre>

<p>The above declares two mappings (SSS and DDD), they are identical SSS is considered the source operand, DDD the destination. Similar to what happens when an identifier + bit size (see Instructions continued) is given to an opcode definition, the compiler expands the SSS and DDD parts of the opcode. However it will now only expand them to the values specified in the first column of the mapping. So this gives 7 out of 8 possible bit values (since %110 is commented out). Within the instruction itself, you can reference the SSS or DDD's and when you do the compiler will insert the expression in the third column of the mapping in its place. Finally, the "MOV %M1,%M0" string (that is used in disassembler generation) automatically replaces the %Mn values with the appropriate item from the second column. So one possible opcode generated by the above is %01111011 the code below is equivalent : </p>

<pre style="background-color:#CCCCCC">
<b>INSTRUCTION</b> "MOV A,E" %01111011
{
	A <b>&lt-</b> E;
}
</pre>
<p></p>

<h2><u>Instructions with immediate data</u></h2>

<p>CISC processors often have multi operand instructions that would not fit within the opcode alone. E.g. "CALL $00FF" on the 8080 this encodes as %11001101 %11111111 %00000000 which is 3 bytes, the hi and lo order bytes of the address are flipped. In EDL these additional bytes can be specified (comma seperated) after the instruction opcode. However they are ignored, the reason being that the memory system is not part of the cpu and therefor the logic to retrieve those values is part of the instruction itself.</p>

<pre style="background-color:#CCCCCC">
<b>INSTRUCTION</b> "CALL %$2%$1" %11001101,B2[8],B3[8]
{
}
</pre>

<p>For disassembler purposes the %$n components are used to specify the offset from the address being disassembled that the subsequent operands can be found.</p>
<p></p>


