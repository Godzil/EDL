INSTANCE "../../chips/Accurate/rp2c02_pixel.edl" AS Pixel;


PIN IN			_RST[1];			# Reset Pin

PIN IN			CLK[1];			# 21.48Mhz

PIN OUT			_INT[1];			# CPU Facing - Connected to NMI pin on CPU
PIN IN			RW[1];			# CPU Facing - Connected to 2A03 RW pin
PIN BIDIRECTIONAL	D[8];			# CPU Facing - Data Bus
PIN IN			RS[3];			# CPU Facing - Register Select (internal registers)
PIN IN			_DBE[1];			# CPU Facing - Data Bus Enable

PIN OUT			VIDEO[8];			# Composite Video Signal - ANALOG (but for now digitised to 8bits)

PIN OUT			ALE[1];			# VRAM Facing - Address Low Enable
PIN OUT			_WE[1];			# VRAM Facing - Write Enable
PIN OUT			_RE[1];			# VRAM Facing - Read Enable
PIN BIDIRECTIONAL	AD[8];			# VRAM Facing - Data Lines (used for Low 8 bits of address as well)
PIN OUT			PA[6];			# VRAM Facing - Top 6 bits of address

### Clock Dividers

DECLARE INTERNAL	pixelCounter[2];
DECLARE INTERNAL	colourCounter[4];
DECLARE INTERNAL	ntscCounter[2];

DECLARE INTERNAL	bigCounter[16];

DECLARE INTERNAL	pixelClk[1];

HANDLER	_RST	ALWAYS
{
	Pixel PIN__RST<-_RST;
	_INT<-Pixel PIN__INT;
}

HANDLER _DBE	ALWAYS
{
	Pixel PIN_RW<-RW;
	Pixel PIN_D<-D;
	Pixel PIN_RS<-RS;
	Pixel PIN__DBE<-_DBE;
	D<-Pixel PIN_D;
	_INT<-Pixel PIN__INT;
}

FUNCTION INTERNAL PixelClock
{
	pixelCounter<-pixelCounter+1;
	IF pixelCounter==0
	{
		pixelClk<-~pixelClk;
		Pixel PIN_AD<-AD;
		Pixel PIN_CLK<-pixelClk;
		ALE<-Pixel PIN_ALE;
		_WE<-Pixel PIN__WE;
		_RE<-Pixel PIN__RE;
		AD<-Pixel PIN_AD;
		PA<-Pixel PIN_PA;
		_INT<-Pixel PIN__INT;
	}
}

FUNCTION INTERNAL NTSCClock
{
#	ntscCounter<-ntscCounter+1;
#	IF ntscCounter==3
#	{
		DECLARE curV[9];
		DECLARE curH[9];

		curV<-Pixel PIN_VCLOCK;
		curH<-Pixel PIN_HCLOCK;

		ntscCounter<-0;

		VIDEO<-4;
		IF ~((curV>=8) & (curV<=11))
		{
			EXECUTE ntscLevel curH;
		}
#	}
}

FUNCTION INTERNAL ColourClock
{
	colourCounter<-colourCounter+1;
	IF colourCounter==12
	{
		colourCounter<-0;
	}
}

FUNCTION INTERNAL UpdateClock
{
	CALL PixelClock();
	CALL NTSCClock();
	CALL ColourClock();
}

HANDLER CLK	TRANSITION(0,1)
{
	CALL UpdateClock();
}

HANDLER CLK	TRANSITION(1,0)
{
	CALL UpdateClock();
}

#### NTSC signal Line Break Down

MAPPING background[9]
{
	256 	""	0;
	257	""	0;
	258 	""	0;
	259 	""	0;
	260 	""	0;
	261 	""	0;
	262 	""	0;
	263 	""	0;
	264 	""	0;
	265 	""	0;
	266	""	0;
	326	""	0;
	327	""	0;
	328	""	0;
	329	""	0;
	330	""	0;
	331	""	0;
	332	""	0;
	333	""	0;
	334	""	0;
	335	""	0;
	336	""	0;
	337	""	0;
	338	""	0;
	339	""	0;
	340	""	0;
}

MAPPING black[9]
{
	267	""	0;
	268	""	0;
	269	""	0;
	270	""	0;
	271	""	0;
	272	""	0;
	273	""	0;
	274	""	0;
	275	""	0;
	301	""	0;
	302	""	0;
	303	""	0;
	304	""	0;
	320	""	0;
	321	""	0;
	322	""	0;
	323	""	0;
	324	""	0;
	325	""	0;
}

MAPPING sync[9]
{
	276	""	0;
	277	""	0;
	278	""	0;
	279	""	0;
	280	""	0;
	281	""	0;
	282	""	0;
	283	""	0;
	284	""	0;
	285	""	0;
	286	""	0;
	287	""	0;
	288	""	0;
	289	""	0;
	290	""	0;
	291	""	0;
	292	""	0;
	293	""	0;
	294	""	0;
	295	""	0;
	296	""	0;	
	297	""	0;
	298	""	0;
	299	""	0;
	300	""	0;
}

MAPPING cburst[9]
{
	305	""	0;
	306	""	0;
	307	""	0;
	308	""	0;
	309	""	0;
	310	""	0;
	311	""	0;
	312	""	0;
	313	""	0;
	314	""	0;
	315	""	0;
	316	""	0;
	317	""	0;
	318	""	0;
	319	""	0;
}

DECLARE lumaTable[[2]][8] {70,120,150,200};

#			Absol	 Rel	 Normalized	Assuming Sync At 4 with Relative Values  ((200-4)/1.96)
#Synch		 	0.781	 0.000	 -0.359		4
#Colorburst L	 	1.000	 0.218	 -0.208		25
#Colorburst H	 	1.712	 0.931	 0.286		97
#Color 0D	 	1.131	 0.350	 -0.117		39
#Color 1D (black)	1.300	 0.518	 0.000		55
#Color 2D	 	1.743	 0.962	 0.308		100
#Color 3D	 	2.331	 1.550	 0.715		159
#Color 00	 	1.875	 1.090	 0.397		113
#Color 10	 	2.287	 1.500	 0.681		154
#Color 20	 	2.743	 1.960	 1.000		200
#Color 30	 	2.743	 1.960	 1.000		200

DECLARE lowTable[[2]][8] {39,55,100,159};
DECLARE hiTable[[2]][8] {113,154,200,200};

#static int TopBottomPercentage[12]={64,104,128,128,128,104,64,24,0,0,0,24};
#int range = activeNTSCSignalHi-activeNTSCSignalLow;
#	int inRangeR=((colourClock+0+5)%12)<6;
#	int inRangeG=((colourClock+4+5)%12)<6;
#	int inRangeB=((colourClock+8+5)%12)<6;
#	int actualLevel=(range*TopBottomPercentage[(colourClock+activeNTSCSignalCol)%12])/128;
#
#	if (((regs2C02[1]&0x20 && inRangeR) ||
#	    (regs2C02[1]&0x40 && inRangeG) ||
#	    (regs2C02[1]&0x80 && inRangeB)) && activeNTSCDisplay)
#	{
#		actualLevel*=.546f;
#		actualLevel-=SIGNAL_RANGE*.0902f;
#	}
#//	else
#//		actualLevel+=15;
#
#	actualLevel+=activeNTSCSignalLow;
#	if (actualLevel<0)
#		printf("Level : %d\n",actualLevel);
#*/

#DECLARE INTERNAL waveTable[[4]][16]	{5,6,7,8,7,6,3,2,1,0,1,2};
#DECLARE INTERNAL waveTable[[4]][16]	{7,8,8,8,8,7,6,0,0,0,0,6};

DECLARE INTERNAL waveTable[[4]][16]	{0,0,1,1,2,2,3,3,2,2,1,1};

FUNCTION INTERNAL value[8] LumaColourMixer low[8],high[8],phase[4]
{
	DECLARE c[16];
	DECLARE tmp[16];
	DECLARE wavePhase[8];
	wavePhase<-colourCounter+phase;
	IF wavePhase>11
	{
		wavePhase<-wavePhase-12;
	}
	tmp<-high-low;
#	tmp<-ROL(tmp,c,0,waveTable[[wavePhase]]);
	tmp<-ROR(tmp,c,0,waveTable[[wavePhase]]);

	tmp<-tmp+low;
	value<-tmp;
}

DECLARE __low[8];
DECLARE __high[8];
DECLARE __phase[4];

FUNCTION INTERNAL SetupLHP	ppuLevel[6]
{
	DECLARE palette[6]	ALIAS	level[2]:phase[4];
	palette<-ppuLevel;

	IF phase>13
	{
		level<-1;
	}

	__low<-lowTable[[level]];
	__high<-hiTable[[level]];
	__phase<-phase;

	IF phase==0
	{
		__low<-__high;
	}
	IF phase>12
	{
		__high<-__low;
	}
}

#			static uint8_t levelsLow[4]={SIGNAL_OFFSET+(-.117f*SIGNAL_RANGE),SIGNAL_OFFSET+(.0f*SIGNAL_RANGE),SIGNAL_OFFSET+(.308f*SIGNAL_RANGE),SIGNAL_OFFSET+(.815f*SIGNAL_RANGE)};
#			static uint8_t levelsHigh[4]={SIGNAL_OFFSET+(.397f*SIGNAL_RANGE),SIGNAL_OFFSET+(.681f*SIGNAL_RANGE),SIGNAL_OFFSET+(1.0f*SIGNAL_RANGE),SIGNAL_OFFSET+(1.0f*SIGNAL_RANGE)};
#
#
#//			lastPixelValue=(curClock>>4)|((curLine-21)&0x30);
#
#			uint8_t level=(lastPixelValue&0x30)>>4;
#			uint8_t colour=lastPixelValue&0x0F;
#
#			if (colour>13)
#				level=1;
#
#			uint8_t levelLow=levelsLow[level]/*(level<<0)*/;
#			uint8_t levelHigh=levelsHigh[level]/*(level<<6)*/;
#
#//			uint8_t levelLow=SIGNAL_OFFSET+((level+1)<<3);
#//			uint8_t levelHigh=SIGNAL_OFFSET+((level+1)<<6);
#
#			if (colour==0)
#			{
#				levelLow=levelHigh;
#			}
#			if (colour>12)
#			{
#				levelHigh=levelLow;
#			}
#			activeNTSCSignalLow=levelLow;
#			activeNTSCSignalHi=levelHigh;
#			activeNTSCSignalCol=colour+5;
#			activeNTSCDisplay=1;
#		}
#		else

INSTRUCTION ntscLevel	"active"	%0:dontcare[8]
{
	CALL SetupLHP(Pixel PIN_ACTIVECOL);
	
	VIDEO<-CALL LumaColourMixer(__low,__high,__phase);#lumaTable[[Pixel PIN_ACTIVECOL]];
}

INSTRUCTION ntscLevel	"background"	background
{
	CALL SetupLHP(Pixel PIN_BKGCOL);

	VIDEO<-CALL LumaColourMixer(__low,__high,__phase);#lumaTable[[Pixel PIN_BKGCOL]];
}

INSTRUCTION ntscLevel	"black"		black
{
	VIDEO<-60;
}

INSTRUCTION ntscLevel	"sync"		sync
{
	VIDEO<-4;
}

INSTRUCTION ntscLevel	"colourburst"	cburst
{
	VIDEO<-CALL LumaColourMixer(25,97,0);
}

#
#
#/*Synch	 	0.781	 0.000	 -0.359
#Colorburst L	 1.000	 0.218	 -0.208
#Colorburst H	 1.712	 0.931	 0.286
#Color 0D	 1.131	 0.350	 -0.117
#Color 1D (black) 1.300	 0.518	 0.000
#Color 2D	 1.743	 0.962	 0.308
#Color 3D	 2.331	 1.550	 0.715
#Color 00	 1.875	 1.090	 0.397
#Color 10	 2.287	 1.500	 0.681
#Color 20	 2.743	 1.960	 1.000
#Color 30	 2.743	 1.960	 1.000
#*/
#
#			static uint8_t levelsLow[4]={SIGNAL_OFFSET+(-.117f*SIGNAL_RANGE),SIGNAL_OFFSET+(.0f*SIGNAL_RANGE),SIGNAL_OFFSET+(.308f*SIGNAL_RANGE),SIGNAL_OFFSET+(.815f*SIGNAL_RANGE)};
#			static uint8_t levelsHigh[4]={SIGNAL_OFFSET+(.397f*SIGNAL_RANGE),SIGNAL_OFFSET+(.681f*SIGNAL_RANGE),SIGNAL_OFFSET+(1.0f*SIGNAL_RANGE),SIGNAL_OFFSET+(1.0f*SIGNAL_RANGE)};
#
#
#//			lastPixelValue=(curClock>>4)|((curLine-21)&0x30);
#
#			uint8_t level=(lastPixelValue&0x30)>>4;
#			uint8_t colour=lastPixelValue&0x0F;
#
#			if (colour>13)
#				level=1;
#
#			uint8_t levelLow=levelsLow[level]/*(level<<0)*/;
#			uint8_t levelHigh=levelsHigh[level]/*(level<<6)*/;
#
#//			uint8_t levelLow=SIGNAL_OFFSET+((level+1)<<3);
#//			uint8_t levelHigh=SIGNAL_OFFSET+((level+1)<<6);
#
#			if (colour==0)
#			{
#				levelLow=levelHigh;
#			}
#			if (colour>12)
#			{
#				levelHigh=levelLow;
#			}
#			activeNTSCSignalLow=levelLow;
#			activeNTSCSignalHi=levelHigh;
#			activeNTSCSignalCol=colour+5;
#			activeNTSCDisplay=1;
#		}
#		else
