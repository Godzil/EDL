#
#	NTSC TIA 
#

PIN OUT			SYNC[1];		# Composite Video Sync
PIN OUT 		_RDY[1];		# To RDY on CPU
PIN OUT 		O0[1];			# To Clock Input on CPU
PIN OUT 		LUM1[1];		# Luminance Output 1
PIN OUT 		BLK[1];			# Vertical Blanking Output
PIN OUT 		LUM2[1];		# Luminance Output 2
PIN OUT 		LUM0[1];		# Luminance Output 0
PIN OUT 		COL[4];			# Colour Output			- Analogue? For now its the colour index
PIN IN			DEL[1];			# Colour Delay Input
PIN IN			OSC[1];			# Clock Input
PIN OUT 		AUD0[1];		# Audio Output			- Analogue
PIN OUT			AUD1[1];		# Audio Output			- Analogue
PIN IN			DB05[6];		# Processor Data Bus Bits 0-5
PIN IN			DI[4];			# "Dumped" inputs
PIN IN			LI[2];			# Latched inputs
PIN BIDIRECTIONAL	DB67[2];		# Processor Data Bus Bits 6-7
PIN IN			AB[6];			# Address bus
PIN IN			O2[1];			# O2 Clock from CPU
PIN IN			RW[1];			# R/~W
PIN IN			_CS0[1];		# Chip Selects 0,2,3 low 1 high for chip selected
PIN IN			CS1[1];
PIN IN			_CS2[1];
PIN IN			_CS3[1];


###

DECLARE		o0_clk_counter[2];
DECLARE		O0_actual[1];

DECLARE		Div4[2];			# Clock Divider

DECLARE		HCounter[6]			{%111111};			# Polynomial counter
DECLARE		HReset[1];							# Used to cause next count to be reset

DECLARE		PlayerCounterEnable[1];

DECLARE		Player0Counter[6]		{%111111};
DECLARE		Player0Reset[1];
DECLARE		Player0Draw[1];
DECLARE		Player0Bit[3];

DECLARE		GRP0Delay[1];

DECLARE		GRP0[[3]][1];

DECLARE		VSYNC[1];
DECLARE		HSYNC[1];

DECLARE		HBLANK[1];
DECLARE		VBLANK[1];

DECLARE		LUBK[3];			# Current Bkground Luminance
DECLARE		COBK[4];			# Current Bkground Colour

DECLARE		LUPF[3];			# Current Playfield Luminance
DECLARE		COPF[4];			# Current Playfield Colour

DECLARE		LUP0[3];			# Current Player 0 Luminance
DECLARE		COP0[4];			# Current Player 0 Colour
DECLARE		LUP1[3];			# Current Player 1 Luminance
DECLARE		COP1[4];			# Current Player 1 Colour

DECLARE		CTRLPF[5]	ALIAS	BALLSIZE[2]:PFP[1]:SCORE[1]:REF[1];

DECLARE		PF[20]		ALIAS	PF0[4]:PF1[8]:PF2[8];# {%10101010101010101010};		# Stored in normalised order for quicker indexing

DECLARE		pfIndex[8];
DECLARE		pfMayMirror[1];
DECLARE		pfDelay[4];

FUNCTION INTERNAL outCounter[6]	UpdatePolyCounter	inCounter[6]
{
	DECLARE nextState[6]	ALIAS newBit[1]:oldBits[5];

	inCounter[1..5]->oldBits;
	~((inCounter[0..0]) ^ (inCounter[1..1]))->newBit;

	outCounter<-nextState;
}

FUNCTION INTERNAL UpdateO0
{
	o0_clk_counter<-o0_clk_counter+1;

	IF o0_clk_counter==3
	{
		o0_clk_counter<-0;
		O0_actual<-~O0_actual;
		O0<-O0_actual;
	}

	SYNC<-VSYNC | HSYNC;
}

FUNCTION INTERNAL	PlayfieldMux
{
	IF (HBLANK|VBLANK)
	{
		LUM0<-0;
		LUM1<-0;
		LUM2<-0;
		COL<-0;
	}
	IF ~(HBLANK|VBLANK)
	{
		#Clock playfield things here
		DECLARE col[1];
		DECLARE T[1];

		IF pfMayMirror&REF
		{
			AFFECT col AS BIT(0) {ROR(PF,T,0,pfIndex-1) };
		}
		IF ~(pfMayMirror&REF)
		{
			AFFECT col AS BIT(19) {ROL(PF,T,0,pfIndex-1) };
		}
		ROL(pfDelay,col,col,1)->pfDelay;

		IF col
		{
			IF SCORE
			{
				IF pfMayMirror
				{
					LUM0<-LUP1[0..0];
					LUM1<-LUP1[1..1];
					LUM2<-LUP1[2..2];
					COL<-COP1;
				}
				IF ~pfMayMirror
				{
					LUM0<-LUP0[0..0];
					LUM1<-LUP0[1..1];
					LUM2<-LUP0[2..2];
					COL<-COP0;
				}
			}
			IF ~SCORE
			{
				LUM0<-LUPF[0..0];
				LUM1<-LUPF[1..1];
				LUM2<-LUPF[2..2];
				COL<-COPF;
			}
		}
		IF ~col
		{
			LUM0<-LUBK[0..0];
			LUM1<-LUBK[1..1];
			LUM2<-LUBK[2..2];
			COL<-COBK;
		}

		IF GRP0Delay
		{
			LUM0<-1;
			LUM1<-1;
			LUM2<-1;
			COL<-0;
		}
		GRP0Delay<-0;
		IF Player0Draw
		{
			IF Player0Bit==%111
			{
				Player0Draw<-0;
			}
			GRP0Delay<-GRP0[[Player0Bit]];
			Player0Bit<-Player0Bit+1;
		}
	}
}

FUNCTION INTERNAL	tick[1]	UpdateDiv4
{
	AFFECT tick AS CARRY(1) { Div4+1 }->Div4;
}

HANDLER	OSC	TRANSITION(0,1)
{
	IF CALL UpdateDiv4()
	{
		CALL UpdatePolyCounter(HCounter)->HCounter;
	
		IF (HCounter==%111111) | HReset
		{
			pfMayMirror<-0;
			pfIndex<-0;

			HReset<-0;
			HCounter<-0;

			HBLANK<-1;

			_RDY<-1;
		}

		EXECUTE HClockLogic HCounter;

		IF PlayerCounterEnable
		{
			CALL UpdatePolyCounter(Player0Counter)->Player0Counter;

			IF (Player0Counter==%111111) | Player0Reset
			{
				Player0Reset<-0;
				Player0Counter<-0;
			}
			EXECUTE PlayerLogic Player0Counter;
		}
	}
	CALL PlayfieldMux();
	CALL UpdateO0();
}

HANDLER OSC	TRANSITION(1,0)
{

	CALL UpdateO0();
}

HANDLER O2	TRANSITION(0,1)
{
	IF ~RW
	{
		IF (~_CS0) & (~_CS2) & (~_CS3) & CS1
		{
			EXECUTE WriteRegister AB;
		}
	}
	IF RW
	{
		IF (~_CS0) & (~_CS2) & (~_CS3) & CS1
		{
			#DEBUG_TRACE "TIA Possible Register Read",BASE 16,AB;
		}
	}
}

####### Register Handlers

MAPPING TODO[6]
{
#	%000000	""	$0;
#	%000001	""	$1;
#	%000010	""	$2;
#	%000011	""	$3;
	%000100	""	$4;
	%000101	""	$5;
#	%000110	""	$6;
#	%000111	""	$7;
#	%001000	""	$8;
#	%001001	""	$9;
#	%001010	""	$A;
	%001011	""	$B;
	%001100	""	$C;
#	%001101	""	$D;
#	%001110	""	$E;
#	%001111	""	$F;
#	%010000	""	$10;
	%010001	""	$11;
	%010010	""	$12;
	%010011	""	$13;
	%010100	""	$14;
	%010101	""	$15;
	%010110	""	$16;
	%010111	""	$17;
	%011000	""	$18;
	%011001	""	$19;
	%011010	""	$1A;
#	%011011	""	$1B;
	%011100	""	$1C;
	%011101	""	$1D;
	%011110	""	$1E;
	%011111	""	$1F;
	%100000	""	$20;
	%100001	""	$21;
	%100010	""	$22;
	%100011	""	$23;
	%100100	""	$24;
	%100101	""	$25;
	%100110	""	$26;
	%100111	""	$27;
	%101000	""	$28;
	%101001	""	$29;
	%101010	""	$2A;
	%101011	""	$2B;
	%101100	""	$2C;
	%101101	""	$2D;
	%101110	""	$2E;
	%101111	""	$2F;
	%110000	""	$30;
	%110001	""	$31;
	%110010	""	$32;
	%110011	""	$33;
	%110100	""	$34;
	%110101	""	$35;
	%110110	""	$36;
	%110111	""	$37;
	%111000	""	$38;
	%111001	""	$39;
	%111010	""	$3A;
	%111011	""	$3B;
	%111100	""	$3C;
	%111101	""	$3D;
	%111110	""	$3E;
	%111111	""	$3F;
}

INSTRUCTION	WriteRegister	"TODO"		TODO
{
	DEBUG_TRACE "TIA : Unknown Register Write",TODO;
}

INSTRUCTION	WriteRegister	"VSYNC"		%000000
{
	VSYNC<-(DB05[1..1]);
	#DEBUG_TRACE "TIA : VSYNC - ------S-";
}

INSTRUCTION	WriteRegister	"VBLANK"	%000001
{
	BLK<-(DB05[1..1]);
	VBLANK<-(DB05[1..1]);

	#DEBUG_TRACE "TIA : VBLANK - xx----V-";
}

INSTRUCTION	WriteRegister	"WSYNC"		%000010
{
	_RDY<-0;
	#DEBUG_TRACE "TIA : WSYNC - ASSERT RDY (strobe)";
}

INSTRUCTION	WriteRegister	"RSYNC"		%000011
{
	HReset<-1;
	#DEBUG_TRACE "TIA : RSYNC - Reset Timing (strobe)";
}

INSTRUCTION	WriteRegister	"COLUP0"	%000110
{
	DECLARE	colGlue[4]	ALIAS	d67[2]:d54[2];
	DECLARE	lumGlue[3]	ALIAS	d3[1]:d2[1]:d1[1];

	d67<-DB67;
	d54<-DB05[4..5];
	d3<-DB05[3..3];
	d2<-DB05[2..2];
	d1<-DB05[1..1];

	COP0<-colGlue;
	LUP0<-lumGlue;

	#DEBUG_TRACE "TIA : COLUP0 - CCCClll-",COP0,LUP0,DB67,DB05;
}

INSTRUCTION	WriteRegister	"COLUP1"	%000111
{
	DECLARE	colGlue[4]	ALIAS	d67[2]:d54[2];
	DECLARE	lumGlue[3]	ALIAS	d3[1]:d2[1]:d1[1];

	d67<-DB67;
	d54<-DB05[4..5];
	d3<-DB05[3..3];
	d2<-DB05[2..2];
	d1<-DB05[1..1];

	COP1<-colGlue;
	LUP1<-lumGlue;

	#DEBUG_TRACE "TIA : COLUP1 - CCCClll-",COP1,LUP1,DB67,DB05;
}

INSTRUCTION	WriteRegister	"COLUPF"	%001000
{
	DECLARE	colGlue[4]	ALIAS	d67[2]:d54[2];
	DECLARE	lumGlue[3]	ALIAS	d3[1]:d2[1]:d1[1];

	d67<-DB67;
	d54<-DB05[4..5];
	d3<-DB05[3..3];
	d2<-DB05[2..2];
	d1<-DB05[1..1];

	COPF<-colGlue;
	LUPF<-lumGlue;

	#DEBUG_TRACE "TIA : COLUPF - CCCClll-",COPF,LUPF,DB67,DB05;
}

INSTRUCTION	WriteRegister	"COLUBK"	%001001
{
	DECLARE	colGlue[4]	ALIAS	d67[2]:d54[2];
	DECLARE	lumGlue[3]	ALIAS	d3[1]:d2[1]:d1[1];

	d67<-DB67;
	d54<-DB05[4..5];
	d3<-DB05[3..3];
	d2<-DB05[2..2];
	d1<-DB05[1..1];

	COBK<-colGlue;
	LUBK<-lumGlue;

	#DEBUG_TRACE "TIA : COLUBK - CCCClll-",COBK,LUBK,DB67,DB05;
}

INSTRUCTION	WriteRegister	"CTRLPF"	%001010
{
	REF<-DB05[0..0];
	SCORE<-DB05[1..1];
	PFP<-DB05[2..2];
	BALLSIZE<-DB05[4..5];

	#DEBUG_TRACE "TIA : CTRLPF - --SS-psr",BALLSIZE,PFP,SCORE,REF;
}

INSTRUCTION	WriteRegister	"PF0"	%001101
{
	DECLARE dbGlue[4]	ALIAS	d4[1]:d5[1]:d6[1]:d7[1];

	d4<-(DB05[4..4]);
	d5<-(DB05[5..5]);
	d6<-(DB67[0..0]);
	d7<-(DB67[1..1]);

	PF0<-dbGlue;

	#DEBUG_TRACE "TIA : PF0 - xxxx---- ",PF0;
}

INSTRUCTION	WriteRegister	"PF1"	%001110
{
	DECLARE dbGlue[8]	ALIAS	d67[2]:d50[6];

	d67<-DB67;
	d50<-DB05;

	PF1<-dbGlue;

	#DEBUG_TRACE "TIA : PF1 - xxxxxxxx ",PF1;
}

INSTRUCTION	WriteRegister	"PF2"	%001111
{
	DECLARE dbGlue[8]	ALIAS	d0[1]:d1[1]:d2[1]:d3[1]:d4[1]:d5[1]:d6[1]:d7[1];

	d0<-(DB05[0..0]);
	d1<-(DB05[1..1]);
	d2<-(DB05[2..2]);
	d3<-(DB05[3..3]);
	d4<-(DB05[4..4]);
	d5<-(DB05[5..5]);
	d6<-(DB67[0..0]);
	d7<-(DB67[1..1]);

	PF2<-dbGlue;

	#DEBUG_TRACE "TIA : PF2 - xxxxxxxx ",PF2;
}

INSTRUCTION	WriteRegister	"RESP0"	%010000
{
	Player0Reset<-1;

	DEBUG_TRACE "TIA : RESP0 (strobe)";
}

INSTRUCTION	WriteRegister	"GRP0"	%011011
{
	DECLARE dbGlue[8]	ALIAS	d67[2]:d05[6];

	d67<-DB67;
	d05<-DB05;

	GRP0[[0]]<-dbGlue[0..0];
	GRP0[[1]]<-dbGlue[1..1];
	GRP0[[2]]<-dbGlue[2..2];
	GRP0[[3]]<-dbGlue[3..3];
	GRP0[[4]]<-dbGlue[4..4];
	GRP0[[5]]<-dbGlue[5..5];
	GRP0[[6]]<-dbGlue[6..6];
	GRP0[[7]]<-dbGlue[7..7];

	DEBUG_TRACE "TIA : GRP0 xxxxxxxx",dbGlue;
}

MAPPING PlayfieldZone[6]
{
#	%011100	"Bit0"		$1;	
	%101110	"Bit1"		$2;	
	%010111 "Bit2"		$3;	
	%101011 "Bit3"		$4;	
	%110101 "Bit4"		$5;	
	%011010 "Bit5"		$6;	
	%001101 "Bit6"		$7;	
	%000110 "Bit7"		$8;	
	%000011 "Bit8"		$9;	
	%100001 "Bit9"		$A;	
	%010000 "Bit10"		$B;	
	%101000 "Bit11"		$C;	
	%110100 "Bit12"		$D;	
	%111010 "Bit13"		$E;	
	%011101 "Bit14"		$F;	
	%001110 "Bit15"		$10;	
	%000111 "Bit16"		$11;	
	%100011 "Bit17"		$12;	
	%110001 "Bit18"		$13;	
	%011000 "Bit19"		$14;	
#	%101100 "Bit0"		$1;	
	%110110 "Bit1"		$2;	
	%011011 "Bit2"		$3;	
	%101101 "Bit3"		$4;	
	%010110 "Bit4"		$5;	
	%001011 "Bit5"		$6;	
	%100101 "Bit6"		$7;	
	%010010 "Bit7"		$8;	
	%001001 "Bit8"		$9;	
	%000100 "Bit9"		$A;	
	%100010 "Bit10"		$B;	
	%010001 "Bit11"		$C;	
	%001000 "Bit12"		$D;	
	%100100 "Bit13"		$E;	
	%110010 "Bit14"		$F;	
	%011001 "Bit15"		$10;	
	%001100 "Bit16"		$11;	
	%100110 "Bit17"		$12;	
	%010011 "Bit18"		$13;	
	%101001 "Bit19"		$14;	
}

####### HClock Handlers

INSTRUCTION	HClockLogic	"%M0"	PlayfieldZone
{
	pfIndex<-PlayfieldZone;
}

INSTRUCTION	HClockLogic	"Center"	%101100
{
	pfMayMirror<-1;
	pfIndex<-$1;
}

INSTRUCTION	HClockLogic	"HSYNC ON"	%111100
{
	HSYNC<-1;
}

INSTRUCTION	HClockLogic	"HSYNC OFF"	%110111
{
	HSYNC<-0;
}

INSTRUCTION	HClockLogic	"RESET HBLK"	%011100
{
	PlayerCounterEnable<-1;
	pfIndex<-$1;
	HBLANK<-0;
}

INSTRUCTION	HClockLogic	"RESET"		%010100
{
	PlayerCounterEnable<-0;
	pfIndex<-$15;
	HReset<-1;
}

######### Player0 Handlers

MAPPING Player0Timer[6]
{
	%000000	""	0;	##	0	0	(draw -012)
	%100000	""	1;	##	1.3	4	(draw 3456)
	%110000	""	2;	##	2.6	8	(draw 7---)
	%111000	""	3;	##	4	12	START DRAWING (NUSIZ=001,011)
	%111100	""	4;	##	5.3	16	(draw -012)
	%111110	""	5;	##	6.6	20	(draw 3456)
	%011111	""	6;	##	8	24	(draw 7---)
	%101111	""	7;	##	9.3	28	START DRAWING (NUSIZ=011,010,110)
	%110111	""	8;	##	10.6	32	(draw -012)
	%111011	""	9;	##	12	36	(draw 3456)
	%111101	""	10;	##	13.3	40	(draw 7---)
	%011110	""	11;	##	14.6	44
	%001111	""	12;	##	16	48
	%100111	""	13;	##	17.3	52
	%110011	""	14;	##	18.6	56
	%111001	""	15;	##	20	60	START DRAWING (NUSIZ=100,110)
	%011100	""	16;	##	21.3	64	(draw -012)
	%101110	""	17;	##	22.6	68	(draw 3456)
	%010111	""	18;	##	24	72	(draw 7---)
	%101011	""	19;	##	25.3	76
	%110101	""	20;	##	26.6	80
	%011010	""	21;	##	28	84
	%001101	""	22;	##	29.3	88
	%000110	""	23;	##	30.6	92
	%000011	""	24;	##	32	96
	%100001	""	25;	##	33.3	100
	%010000	""	26;	##	34.6	104
	%101000	""	27;	##	36	108
	%110100	""	28;	##	37.3	112
	%111010	""	29;	##	38.6	116
	%011101	""	30;	##	40	120
	%001110	""	31;	##	41.3	124
	%000111	""	32;	##	42.6	128
	%100011	""	33;	##	44	132
	%110001	""	34;	##	45.3	136
	%011000	""	35;	##	46.6	140
	%101100	""	36;	##	48	144
	%110110	""	37;	##	49.3	148
	%011011	""	38;	##	50.6	152
#	%101101	""	39;	##	52	156	RESET, START DRAWING (always)
}



INSTRUCTION	PlayerLogic	"RESET"		%101101
{
	Player0Reset<-1;
	Player0Draw<-1;
	Player0Bit<-0;
}


