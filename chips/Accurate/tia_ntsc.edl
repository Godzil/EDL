#
#	NTSC TIA 
#

PIN OUT			SYNC[1];		# Composite Video Sync
PIN OUT 		_RDY[1];		# To RDY on CPU
PIN OUT 		O0[1];			# To Clock Input on CPU
PIN OUT 		LUM1[1];		# Luminance Output 1
PIN OUT 		BLK[1];			# Vertical Blanking Output
PIN OUT 		LUM2[1];		# Luminance Output 2
PIN OUT 		LUM0[1];		# Luminance Output 0
PIN OUT 		COL[4];			# Colour Output			- Analogue? For now its the colour index
PIN IN			DEL[1];			# Colour Delay Input
PIN IN			OSC[1];			# Clock Input
PIN OUT 		AUD0[1];		# Audio Output			- Analogue
PIN OUT			AUD1[1];		# Audio Output			- Analogue
PIN IN			DB05[6];		# Processor Data Bus Bits 0-5
PIN IN			DI[4];			# "Dumped" inputs
PIN IN			LI[2];			# Latched inputs
PIN BIDIRECTIONAL	DB67[2];		# Processor Data Bus Bits 6-7
PIN IN			AB[6];			# Address bus
PIN IN			O2[1];			# O2 Clock from CPU
PIN IN			RW[1];			# R/~W
PIN IN			_CS0[1];		# Chip Selects 0,2,3 low 1 high for chip selected
PIN IN			CS1[1];
PIN IN			_CS2[1];
PIN IN			_CS3[1];


###

DECLARE		o0_clk_counter[2];
DECLARE		O0_actual[1];

DECLARE		Div4[2];			# Clock Divider

DECLARE		HCounter[6]	ALIAS hUpper[4]:h1[1]:h0[1]	{%111111};			# Polynomial counter
DECLARE		HReset[1];							# Used to cause next count to be reset


DECLARE		VSYNC[1];
DECLARE		HSYNC[1];

DECLARE		HBLANK[1];
DECLARE		VBLANK[1];

DECLARE		LUBK[3];			# Current Bkground Luminance
DECLARE		COBK[4];			# Current Bkground Colour

FUNCTION INTERNAL UpdateHCounter
{
	# Check for illegal condition
	IF HCounter==%111111
	{
		HReset<-1;
	}
	IF HCounter!=%111111
	{
		DECLARE nextState[6]	ALIAS newBit[1]:oldBits[5];

		HCounter[1..5]->oldBits;
		~((HCounter[0..0]) ^ (HCounter[1..1]))->newBit;

		HCounter<-nextState;
	}
	IF HReset
	{
		HReset<-0;
		HCounter<-0;

		HBLANK<-1;

		_RDY<-1;
	}

	#DEBUG_TRACE HCounter;

	EXECUTE HClockLogic HCounter;
}

FUNCTION INTERNAL UpdateO0
{
	o0_clk_counter<-o0_clk_counter+1;

	IF o0_clk_counter==3
	{
		o0_clk_counter<-0;
		O0_actual<-~O0_actual;
		O0<-O0_actual;
	}

	SYNC<-VSYNC | HSYNC;

	#TODO - Need MUX
	IF (HBLANK|VBLANK)
	{
		LUM0<-0;
		LUM1<-0;
		LUM2<-0;
		COL<-0;
	}
	IF ~(HBLANK|VBLANK)
	{
		LUM0<-LUBK[0..0];
		LUM1<-LUBK[1..1];
		LUM2<-LUBK[2..2];
		COL<-COBK;
	}
}

FUNCTION INTERNAL	tick[1]	UpdateDiv4
{
	AFFECT tick AS CARRY(1) { Div4+1 }->Div4;
}

HANDLER	OSC	TRANSITION(0,1)
{
	IF CALL UpdateDiv4()
	{
		CALL UpdateHCounter();
	}
	CALL UpdateO0();
}

HANDLER OSC	TRANSITION(1,0)
{

	CALL UpdateO0();
}

HANDLER O2	TRANSITION(0,1)
{
	IF ~RW
	{
		IF (~_CS0) & (~_CS2) & (~_CS3) & CS1
		{
			EXECUTE WriteRegister AB;
		}
	}
	IF RW
	{
		IF (~_CS0) & (~_CS2) & (~_CS3) & CS1
		{
			#DEBUG_TRACE "TIA Possible Register Read",BASE 16,AB;
		}
	}
}

####### Register Handlers

MAPPING TODO[2]
{
	%10	""	%10;
	%11	""	%11;
}

INSTRUCTION	WriteRegister	"TODO"		a[3]:TODO:b[1]
{
	DECLARE debug[6]	ALIAS ia[3]:td[2]:ib[1];

	ia<-a;
	td<-TODO;
	ib<-b;

	DEBUG_TRACE "TIA : Unknown Register Write",debug;
}

INSTRUCTION	WriteRegister	"VSYNC"		%000000
{
	VSYNC<-(DB05[1..1]);
	#DEBUG_TRACE "TIA : VSYNC - ------S-";
}

INSTRUCTION	WriteRegister	"VBLANK"	%000001
{
	BLK<-(DB05[1..1]);
	VBLANK<-(DB05[1..1]);

	#DEBUG_TRACE "TIA : VBLANK - xx----V-";
}

INSTRUCTION	WriteRegister	"WSYNC"		%000010
{
	_RDY<-0;
	#DEBUG_TRACE "TIA : WSYNC - ASSERT RDY (strobe)";
}

INSTRUCTION	WriteRegister	"RSYNC"		%000011
{
	HReset<-1;
	#DEBUG_TRACE "TIA : RSYNC - Reset Timing (strobe)";
}

INSTRUCTION	WriteRegister	"COLUBK"	%001001
{
	DECLARE	colGlue[4]	ALIAS	d67[2]:d54[2];
	DECLARE	lumGlue[3]	ALIAS	d3[1]:d2[1]:d1[1];

	d67<-DB67;
	d54<-DB05[4..5];
	d3<-DB05[3..3];
	d2<-DB05[2..2];
	d1<-DB05[1..1];

	COBK<-colGlue;
	LUBK<-lumGlue;

	#DEBUG_TRACE "TIA : COLUBK - CCCClll-",COBK,LUBK,DB67,DB05;
}

####### HClock Handlers

INSTRUCTION	HClockLogic	"HSYNC ON"	%111100
{
	HSYNC<-1;
}

INSTRUCTION	HClockLogic	"HSYNC OFF"	%110111
{
	HSYNC<-0;
}

INSTRUCTION	HClockLogic	"RESET HBLK"	%011100
{
	HBLANK<-0;
}

INSTRUCTION	HClockLogic	"RESET"		%010100
{
	HReset<-1;
}


